{"ast":null,"code":"class CrosswordKeyActions {\n  tabOrEnter(grid, squareSelection, shiftKey, acrossClues, downClues) {\n    let allClues = acrossClues.concat(downClues);\n    let clueInd = allClues.findIndex(c => squareSelection.direction === \"Across\" ? grid[squareSelection.coords[0]][squareSelection.coords[1]].acrossClueNum === c.number && c.direction === \"ACROSS\" : grid[squareSelection.coords[0]][squareSelection.coords[1]].downClueNum === c.number && c.direction === \"DOWN\");\n    console.log(\"Current clue: \" + allClues[clueInd].number);\n    let boardSize = grid.length;\n    let [r, c] = squareSelection.coords;\n\n    if (squareSelection.direction === \"Across\" && shiftKey) {\n      if (this.gridIsFull(grid)) {// return beginning of prev word\n      }\n    }\n  }\n  /*tabOrEnter (grid, squareSelection, shiftKey) {\n      let boardSize = grid.length\n      let [r,c] = squareSelection.coords\n      if (squareSelection.direction === \"Across\" && shiftKey) {\n          // move backwards to beginning of this word\n          while (grid[r][c].value !== \"_\" && c >= 0) {\n              c--\n          }\n          if (c < 0) {\n              r--\n              c += boardSize\n              if (r < 0) {\n                  r += boardSize\n              }\n          }\n           let puzzleFull = false\n          // now we are on a black square or end of a row, so move back until find empty square\n          while (grid[r][c].value === \"_\" || grid[r][c].value !== \"?\") {\n              c--\n              if (c < 0) {\n                  r--\n                  c += boardSize\n                  if (r < 0) {\n                      r += boardSize\n                  }\n              }\n              // check for infinite loop if puzzle full\n              if (squareSelection.coords === [r,c]) {\n                  puzzleFull = true\n                  break\n              }\n          }\n      \n          // now we are on a blank square so find the beginning of this word\n          while (!grid[r][c].value === \"_\" && c >= 0) {\n              if (grid[r][c].value === \"?\") {\n                  // this is necessary for the case where the only empty square(s) were in the word we were in, \n                  // but were before the current coords we were on in that word\n                  puzzleFull = false \n              }\n              c--\n          }\n          // we went one space too far, so adjust\n          c++\n           // in the case of a full puzzle, the enter/tab key should go to beginning of previous word\n          if (puzzleFull) {\n              // move to end of prev word\n              while (grid[r][c].value === \"_\") {\n                  c--\n                  if (c < 0) {\n                      r--\n                      c += boardSize\n                      if (r < 0) {\n                          r += boardSize\n                      }\n                  }\n              }\n               // move to beginning of prev word\n              while (grid[r][c].value !== \"_\" && c >= 0) {\n                  c--\n              }\n              // readjust\n              c++\n          } else {\n              // if puzzle not full, then our current word has an empty space, so find the first one\n              while (grid[r][c].value !== \"?\") {\n                  c++\n              }\n          }\n          squareSelection.coords = [r,c]\n      } else if (squareSelection.direction === \"Across\" && !shiftKey) {\n          // move forwards to end of this word\n          while (grid[r][c].value !== \"_\" && c < boardSize) {\n              c++\n          }\n          if (c >= boardSize) {\n              r++\n              c -= boardSize\n              if (r >= boardSize) {\n                  r -= boardSize\n              }\n          }\n           let puzzleFull = false\n          // now we are on a black square or beginning of a row, so move forward until find empty square\n          while (grid[r][c].value === \"_\" || grid[r][c].value !== \"?\") {\n              c++\n              if (c >= boardSize) {\n                  r++\n                  c -= boardSize\n                  if (r >= boardSize) {\n                      r -= boardSize\n                  }\n              }\n              // check for infinite loop if puzzle full\n              if (squareSelection.coords === [r,c]) {\n                  puzzleFull = true\n                  break\n              }\n          }\n           if (puzzleFull) {\n              // check end of this word to see if there are empty squares only in this word, but after current coords\n              c++\n              while (grid[r][c].value !== \"_\" && c < boardSize) {\n                  if (grid[r][c].value === \"?\") {\n                      puzzleFull = false\n                      break\n                  }\n              }\n              // if we still haven't found an empty spot in this word, then go to first position in next word\n              if (puzzleFull) {\n                  if (c >= boardSize) {\n                      r++\n                      c -= boardSize\n                      if (r >= boardSize) {\n                          r -= boardSize\n                      }\n                  }\n                  while (grid[r][c].value === \"_\") {\n                      c++\n                      if (c >= boardSize) {\n                          r++\n                          c -= boardSize\n                          if (r >= boardSize) {\n                              r -= boardSize\n                          }\n                      }\n                  }\n              }\n          } else {\n              // \n          }\n      \n          // now we are on a blank square so find the end of this word\n          while (!grid[r][c].value === \"_\" && c >= 0) {\n              if (grid[r][c].value === \"?\") {\n                  // this is necessary for the case where the only empty square(s) were in the word we were in, \n                  // but were before the current coords we were on in that word\n                  puzzleFull = false \n              }\n              c--\n          }\n          // we went one space too far, so adjust\n          c++\n           // in the case of a full puzzle, the enter/tab key should go to beginning of previous word\n          if (puzzleFull) {\n              // move to end of prev word\n              while (grid[r][c].value === \"_\") {\n                  c--\n                  if (c < 0) {\n                      r--\n                      c += boardSize\n                      if (r < 0) {\n                          r += boardSize\n                      }\n                  }\n              }\n               // move to beginning of prev word\n              while (grid[r][c].value !== \"_\" && c >= 0) {\n                  c--\n              }\n              // readjust\n              c++\n          } else {\n              // if puzzle not full, then our current word has an empty space, so find the first one\n              while (grid[r][c].value !== \"?\") {\n                  c++\n              }\n          }\n          squareSelection.coords = [r,c]\n      } else if (squareSelection.direction === \"Down\" && shiftKey) {\n       } else {\n       }\n  }*/\n\n\n  leftArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Down\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      c--;\n\n      if (c < 0) {\n        c += boardSize;\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n          r--;\n\n          if (r < 0) {\n            r += boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  upArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Across\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      r--;\n\n      if (r < 0) {\n        r += boardSize;\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n          c--;\n\n          if (c < 0) {\n            c += boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  rightArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Down\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      c++;\n\n      if (c >= boardSize) {\n        c -= boardSize;\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n          r++;\n\n          if (r >= boardSize) {\n            r -= boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  downArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Across\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      r++;\n\n      if (r >= boardSize) {\n        r -= boardSize;\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n          c++;\n\n          if (c >= boardSize) {\n            c -= boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  gridIsFull(grid) {\n    let boardSize = grid.length;\n\n    for (let r = 0; r < boardSize; r++) {\n      for (let c = 0; c < boardSize; c++) {\n        if (grid[r][c].value === \"?\") {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexport default new CrosswordKeyActions();","map":{"version":3,"sources":["/Users/nathanmajumder/crossword-react-app/crossword-app/src/libs/CrosswordKeyActions.js"],"names":["CrosswordKeyActions","tabOrEnter","grid","squareSelection","shiftKey","acrossClues","downClues","allClues","concat","clueInd","findIndex","c","direction","coords","acrossClueNum","number","downClueNum","console","log","boardSize","length","r","gridIsFull","leftArrow","flipDirection","value","upArrow","rightArrow","downArrow"],"mappings":"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","sourcesContent":["\nclass CrosswordKeyActions {\n    tabOrEnter (grid, squareSelection, shiftKey, acrossClues, downClues) {\n        let allClues = acrossClues.concat(downClues)\n        let clueInd = allClues.findIndex(c => squareSelection.direction === \"Across\"\n                ? grid[squareSelection.coords[0]][squareSelection.coords[1]].acrossClueNum === c.number && c.direction === \"ACROSS\"\n                : grid[squareSelection.coords[0]][squareSelection.coords[1]].downClueNum === c.number && c.direction === \"DOWN\")\n        console.log(\"Current clue: \" + allClues[clueInd].number)\n\n        let boardSize = grid.length\n        let [r,c] = squareSelection.coords\n        if (squareSelection.direction === \"Across\" && shiftKey) {\n            if (this.gridIsFull(grid)) {\n                // return beginning of prev word\n                \n            }\n        }\n    }\n\n    /*tabOrEnter (grid, squareSelection, shiftKey) {\n        let boardSize = grid.length\n        let [r,c] = squareSelection.coords\n        if (squareSelection.direction === \"Across\" && shiftKey) {\n            // move backwards to beginning of this word\n            while (grid[r][c].value !== \"_\" && c >= 0) {\n                c--\n            }\n            if (c < 0) {\n                r--\n                c += boardSize\n                if (r < 0) {\n                    r += boardSize\n                }\n            }\n\n            let puzzleFull = false\n            // now we are on a black square or end of a row, so move back until find empty square\n            while (grid[r][c].value === \"_\" || grid[r][c].value !== \"?\") {\n                c--\n                if (c < 0) {\n                    r--\n                    c += boardSize\n                    if (r < 0) {\n                        r += boardSize\n                    }\n                }\n                // check for infinite loop if puzzle full\n                if (squareSelection.coords === [r,c]) {\n                    puzzleFull = true\n                    break\n                }\n            }\n        \n            // now we are on a blank square so find the beginning of this word\n            while (!grid[r][c].value === \"_\" && c >= 0) {\n                if (grid[r][c].value === \"?\") {\n                    // this is necessary for the case where the only empty square(s) were in the word we were in, \n                    // but were before the current coords we were on in that word\n                    puzzleFull = false \n                }\n                c--\n            }\n            // we went one space too far, so adjust\n            c++\n\n            // in the case of a full puzzle, the enter/tab key should go to beginning of previous word\n            if (puzzleFull) {\n                // move to end of prev word\n                while (grid[r][c].value === \"_\") {\n                    c--\n                    if (c < 0) {\n                        r--\n                        c += boardSize\n                        if (r < 0) {\n                            r += boardSize\n                        }\n                    }\n                }\n\n                // move to beginning of prev word\n                while (grid[r][c].value !== \"_\" && c >= 0) {\n                    c--\n                }\n                // readjust\n                c++\n            } else {\n                // if puzzle not full, then our current word has an empty space, so find the first one\n                while (grid[r][c].value !== \"?\") {\n                    c++\n                }\n            }\n            squareSelection.coords = [r,c]\n        } else if (squareSelection.direction === \"Across\" && !shiftKey) {\n            // move forwards to end of this word\n            while (grid[r][c].value !== \"_\" && c < boardSize) {\n                c++\n            }\n            if (c >= boardSize) {\n                r++\n                c -= boardSize\n                if (r >= boardSize) {\n                    r -= boardSize\n                }\n            }\n\n            let puzzleFull = false\n            // now we are on a black square or beginning of a row, so move forward until find empty square\n            while (grid[r][c].value === \"_\" || grid[r][c].value !== \"?\") {\n                c++\n                if (c >= boardSize) {\n                    r++\n                    c -= boardSize\n                    if (r >= boardSize) {\n                        r -= boardSize\n                    }\n                }\n                // check for infinite loop if puzzle full\n                if (squareSelection.coords === [r,c]) {\n                    puzzleFull = true\n                    break\n                }\n            }\n\n            if (puzzleFull) {\n                // check end of this word to see if there are empty squares only in this word, but after current coords\n                c++\n                while (grid[r][c].value !== \"_\" && c < boardSize) {\n                    if (grid[r][c].value === \"?\") {\n                        puzzleFull = false\n                        break\n                    }\n                }\n                // if we still haven't found an empty spot in this word, then go to first position in next word\n                if (puzzleFull) {\n                    if (c >= boardSize) {\n                        r++\n                        c -= boardSize\n                        if (r >= boardSize) {\n                            r -= boardSize\n                        }\n                    }\n                    while (grid[r][c].value === \"_\") {\n                        c++\n                        if (c >= boardSize) {\n                            r++\n                            c -= boardSize\n                            if (r >= boardSize) {\n                                r -= boardSize\n                            }\n                        }\n                    }\n                }\n            } else {\n                // \n            }\n        \n            // now we are on a blank square so find the end of this word\n            while (!grid[r][c].value === \"_\" && c >= 0) {\n                if (grid[r][c].value === \"?\") {\n                    // this is necessary for the case where the only empty square(s) were in the word we were in, \n                    // but were before the current coords we were on in that word\n                    puzzleFull = false \n                }\n                c--\n            }\n            // we went one space too far, so adjust\n            c++\n\n            // in the case of a full puzzle, the enter/tab key should go to beginning of previous word\n            if (puzzleFull) {\n                // move to end of prev word\n                while (grid[r][c].value === \"_\") {\n                    c--\n                    if (c < 0) {\n                        r--\n                        c += boardSize\n                        if (r < 0) {\n                            r += boardSize\n                        }\n                    }\n                }\n\n                // move to beginning of prev word\n                while (grid[r][c].value !== \"_\" && c >= 0) {\n                    c--\n                }\n                // readjust\n                c++\n            } else {\n                // if puzzle not full, then our current word has an empty space, so find the first one\n                while (grid[r][c].value !== \"?\") {\n                    c++\n                }\n            }\n            squareSelection.coords = [r,c]\n        } else if (squareSelection.direction === \"Down\" && shiftKey) {\n\n        } else {\n\n        }\n    }*/\n\n    leftArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Down\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            c--\n            if (c < 0) {\n                c += boardSize\n                r--\n                if (r < 0) {\n                    r += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c--\n                if (c < 0) {\n                    c += boardSize\n                    r--\n                    if (r < 0) {\n                        r += boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    upArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Across\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            r--\n            if (r < 0) {\n                r += boardSize\n                c--\n                if (c < 0) {\n                    c += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r--\n                if (r < 0) {\n                    r += boardSize\n                    c--\n                    if (c < 0) {\n                        c += boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    rightArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Down\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            c++\n            if (c >= boardSize) {\n                c -= boardSize\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                    r++\n                    if (r >= boardSize) {\n                        r -= boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    downArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Across\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            r++\n            if (r >= boardSize) {\n                r -= boardSize\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                    c++\n                    if (c >= boardSize) {\n                        c -= boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    gridIsFull (grid) {\n        let boardSize = grid.length\n        for (let r = 0; r < boardSize; r++) {\n            for (let c = 0; c < boardSize; c++) {\n                if (grid[r][c].value === \"?\") {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n}\n\nexport default new CrosswordKeyActions()"]},"metadata":{},"sourceType":"module"}