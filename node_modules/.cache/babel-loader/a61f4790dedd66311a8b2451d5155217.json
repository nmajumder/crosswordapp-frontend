{"ast":null,"code":"class CrosswordKeyActions {\n  alphaNumeric(board, key) {\n    let grid = board.grid;\n    let selection = board.selection;\n    let [r, c] = [selection.rowCoord, selection.colCoord];\n    let boardSize = grid.length;\n    let wasEmpty = grid[r][c].value === \"\";\n    grid[r][c].value = key;\n\n    if (selection.direction === \"Across\") {\n      if (wasEmpty || c + 1 === boardSize || grid[r][c + 1].value === \"_\") {\n        // find next open square in the word with wrapping\n        let newCoords = this.getNextEmptySpaceWrapping(board);\n\n        if (newCoords !== null) {\n          selection.rowCoord = newCoords[0];\n          selection.colCoord = newCoords[1];\n        }\n      } else {\n        // go to next square\n        selection.colCoord = c + 1;\n      }\n    } else {\n      if (wasEmpty || r + 1 === boardSize || grid[r + 1][c].value === \"_\") {\n        // find next open square in the word with wrapping\n        let newCoords = this.getNextEmptySpaceWrapping(board);\n\n        if (newCoords !== null) {\n          selection.rowCoord = newCoords[0];\n          selection.colCoord = newCoords[1];\n        }\n      } else {\n        // go to next square\n        selection.rowCoord = r + 1;\n      }\n    }\n\n    return selection;\n  }\n\n  delete(board) {\n    let grid = board.grid;\n    let selection = board.selection;\n    let [r, c] = [selection.rowCoord, selection.colCoord];\n    let boardSize = grid.length;\n    let wasEmpty = grid[r][c].value === \"\";\n\n    if (selection.direction === \"Across\") {\n      if (wasEmpty && c - 1 >= 0 && grid[r][c - 1].value !== \"_\") {\n        // move left a square and delete\n        grid[r][c - 1].value = \"\";\n        selection.colCoord = c - 1;\n      } else {\n        // delete this square and stay put\n        grid[r][c].value = \"\";\n      }\n    } else {\n      if (wasEmpty && r - 1 >= 0 && grid[r - 1][c].value !== \"_\") {\n        // move up a square and delete\n        grid[r - 1][c].value = \"\";\n        selection.rowCoord = r - 1;\n      } else {\n        // delete this square and stay put\n        grid[r][c].value = \"\";\n      }\n    }\n\n    return selection;\n  }\n\n  tabOrEnter(board, shiftKey, acrossClues, downClues) {\n    let grid = board.grid;\n    let selection = board.selection;\n    let allClues = acrossClues.concat(downClues);\n    let clueInd = allClues.findIndex(c => selection.direction === \"Across\" ? grid[selection.rowCoord][selection.colCoord].acrossClueNum === c.number && c.direction === \"Across\" : grid[selection.rowCoord][selection.colCoord].downClueNum === c.number && c.direction === \"Down\");\n    let foundCoords = null;\n    let newDirection = null;\n\n    if (shiftKey) {\n      // going backwards\n      if (this.gridIsFull(grid)) {\n        // return beginning of prev word\n        clueInd--;\n\n        if (clueInd < 0) {\n          clueInd += allClues.length;\n        }\n\n        newDirection = allClues[clueInd].direction;\n        selection.rowCoord = allClues[clueInd].rowCoord;\n        selection.colCoord = allClues[clueInd].colCoord;\n      } else {\n        // find empty square in previous word\n        while (foundCoords === null) {\n          console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction);\n          clueInd--;\n\n          if (clueInd < 0) {\n            clueInd += allClues.length;\n          }\n\n          newDirection = allClues[clueInd].direction;\n          foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd]);\n        }\n\n        selection.rowCoord = foundCoords[0];\n        selection.colCoord = foundCoords[1];\n      }\n    } else {\n      // going forwards\n      if (this.gridIsFull(grid)) {\n        clueInd++;\n\n        if (clueInd >= allClues.length) {\n          clueInd -= allClues.length;\n        }\n\n        newDirection = allClues[clueInd].direction;\n        selection.rowCoord = allClues[clueInd].rowCoord;\n        selection.colCoord = allClues[clueInd].colCoord;\n      } else {\n        // find empty square in next word\n        while (foundCoords === null) {\n          console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction);\n          clueInd++;\n\n          if (clueInd >= allClues.length) {\n            clueInd -= allClues.length;\n          }\n\n          newDirection = allClues[clueInd].direction;\n          foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd]);\n        }\n\n        selection.rowCoord = foundCoords[0];\n        selection.colCoord = foundCoords[1];\n      }\n    }\n\n    selection.direction = newDirection;\n    return selection;\n  }\n\n  leftArrow(board) {\n    let grid = board.grid;\n    let selection = board.selection;\n\n    if (selection.direction === \"Down\") {\n      selection.direction = \"Across\";\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = [selection.rowCoord, selection.colCoord];\n      c--;\n\n      if (c < 0) {\n        c += boardSize;\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n          r--;\n\n          if (r < 0) {\n            r += boardSize;\n          }\n        }\n      }\n\n      selection.rowCoord = r;\n      selection.colCoord = c;\n    }\n\n    return selection;\n  }\n\n  upArrow(board) {\n    let grid = board.grid;\n    let selection = board.selection;\n\n    if (selection.direction === \"Across\") {\n      selection.direction = \"Down\";\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = [selection.rowCoord, selection.colCoord];\n      r--;\n\n      if (r < 0) {\n        r += boardSize;\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n          c--;\n\n          if (c < 0) {\n            c += boardSize;\n          }\n        }\n      }\n\n      selection.rowCoord = r;\n      selection.colCoord = c;\n    }\n\n    return selection;\n  }\n\n  rightArrow(board) {\n    let grid = board.grid;\n    let selection = board.selection;\n\n    if (selection.direction === \"Down\") {\n      selection.direction = \"Across\";\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = [selection.rowCoord, selection.colCoord];\n      c++;\n\n      if (c >= boardSize) {\n        c -= boardSize;\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n          r++;\n\n          if (r >= boardSize) {\n            r -= boardSize;\n          }\n        }\n      }\n\n      selection.rowCoord = r;\n      selection.colCoord = c;\n    }\n\n    return selection;\n  }\n\n  downArrow(board) {\n    let grid = board.grid;\n    let selection = board.selection;\n\n    if (selection.direction === \"Across\") {\n      selection.direction = \"Down\";\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = [selection.rowCoord, selection.colCoord];\n      r++;\n\n      if (r >= boardSize) {\n        r -= boardSize;\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n          c++;\n\n          if (c >= boardSize) {\n            c -= boardSize;\n          }\n        }\n      }\n\n      selection.rowCoord = r;\n      selection.colCoord = c;\n    }\n\n    return selection;\n  }\n\n  gridIsFull(grid) {\n    let boardSize = grid.length;\n\n    for (let r = 0; r < boardSize; r++) {\n      for (let c = 0; c < boardSize; c++) {\n        if (grid[r][c].value === \"\") {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  getFirstEmptySpace(grid, clue) {\n    let [row, col] = [clue.rowCoord, clue.colCoord];\n\n    if (clue.direction === \"Across\") {\n      for (let i = col; i < col + clue.answerLength; i++) {\n        if (grid[row][i].value === \"\") {\n          return [row, i];\n        }\n      }\n    } else {\n      for (let i = row; i < row + clue.answerLength; i++) {\n        if (grid[i][col].value === \"\") {\n          return [i, col];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  getNextEmptySpaceWrapping(board) {\n    let grid = board.grid;\n    let selection = board.selection;\n    let [r, c] = [selection.rowCoord, selection.colCoord];\n\n    if (selection.direction === \"Across\") {\n      do {\n        c++;\n\n        if (c >= grid.length || grid[r][c].value === \"_\") {\n          // go to beginning of word\n          c = c - grid[r][c - 1].acrossWordIndex - 1;\n        }\n\n        if (grid[r][c].value === \"\") {\n          return [r, c];\n        }\n      } while (c !== selection.colCoord);\n    } else {\n      do {\n        r++;\n\n        if (r >= grid.length || grid[r][c].value === \"_\") {\n          // go to beginning of word\n          r = r - grid[r - 1][c].downWordIndex - 1;\n        }\n\n        if (grid[r][c].value === \"\") {\n          return [r, c];\n        }\n      } while (r !== selection.rowCoord);\n    }\n\n    return null;\n  }\n\n}\n\nexport default new CrosswordKeyActions();","map":{"version":3,"sources":["/Users/nathanmajumder/crossword-react-app/crossword-app/src/libs/CrosswordKeyActions.js"],"names":["CrosswordKeyActions","alphaNumeric","board","key","grid","selection","r","c","rowCoord","colCoord","boardSize","length","wasEmpty","value","direction","newCoords","getNextEmptySpaceWrapping","delete","tabOrEnter","shiftKey","acrossClues","downClues","allClues","concat","clueInd","findIndex","acrossClueNum","number","downClueNum","foundCoords","newDirection","gridIsFull","console","log","getFirstEmptySpace","leftArrow","upArrow","rightArrow","downArrow","clue","row","col","i","answerLength","acrossWordIndex","downWordIndex"],"mappings":"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","sourcesContent":["class CrosswordKeyActions {\n    alphaNumeric (board, key) {\n        let grid = board.grid\n        let selection = board.selection\n        let [r, c] = [selection.rowCoord, selection.colCoord]\n        let boardSize = grid.length\n        let wasEmpty = grid[r][c].value === \"\"\n        grid[r][c].value = key\n        if (selection.direction === \"Across\") {\n            if (wasEmpty || c+1 === boardSize || grid[r][c+1].value === \"_\") {\n                // find next open square in the word with wrapping\n                let newCoords = this.getNextEmptySpaceWrapping(board)\n                if (newCoords !== null) {\n                    selection.rowCoord = newCoords[0]\n                    selection.colCoord = newCoords[1]\n                }\n            } else {\n                // go to next square\n                selection.colCoord = c+1\n            }\n        } else {\n            if (wasEmpty || r+1 === boardSize || grid[r+1][c].value === \"_\") {\n                // find next open square in the word with wrapping\n                let newCoords = this.getNextEmptySpaceWrapping(board)\n                if (newCoords !== null) {\n                    selection.rowCoord = newCoords[0]\n                    selection.colCoord = newCoords[1]\n                }\n            } else {\n                // go to next square\n                selection.rowCoord = r+1\n            }\n        }\n        return selection\n    }\n\n    delete (board) {\n        let grid = board.grid\n        let selection = board.selection\n        let [r, c] = [selection.rowCoord, selection.colCoord]\n        let boardSize = grid.length\n        let wasEmpty = grid[r][c].value === \"\"\n        if (selection.direction === \"Across\") {\n            if (wasEmpty && c-1 >= 0 && grid[r][c-1].value !== \"_\") {\n                // move left a square and delete\n                grid[r][c-1].value = \"\"\n                selection.colCoord = c-1\n            } else {\n                // delete this square and stay put\n                grid[r][c].value = \"\"\n            }\n        } else {\n            if (wasEmpty && r-1 >= 0 && grid[r-1][c].value !== \"_\") {\n                // move up a square and delete\n                grid[r-1][c].value = \"\"\n                selection.rowCoord = r-1\n            } else {\n                // delete this square and stay put\n                grid[r][c].value = \"\"\n            }\n        }\n        return selection\n    }\n\n    tabOrEnter (board, shiftKey, acrossClues, downClues) {\n        let grid = board.grid\n        let selection = board.selection\n        let allClues = acrossClues.concat(downClues)\n        let clueInd = allClues.findIndex(c => selection.direction === \"Across\"\n                ? grid[selection.rowCoord][selection.colCoord].acrossClueNum === c.number && c.direction === \"Across\"\n                : grid[selection.rowCoord][selection.colCoord].downClueNum === c.number && c.direction === \"Down\")\n        let foundCoords = null\n        let newDirection = null\n        if (shiftKey) {\n            // going backwards\n            if (this.gridIsFull(grid)) {\n                // return beginning of prev word\n                clueInd--\n                if (clueInd < 0) {\n                    clueInd += allClues.length\n                }\n                newDirection = allClues[clueInd].direction\n                selection.rowCoord = allClues[clueInd].rowCoord\n                selection.colCoord = allClues[clueInd].colCoord\n            } else {\n                // find empty square in previous word\n                while (foundCoords === null) {\n                    console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction)\n                    clueInd--\n                    if (clueInd < 0) {\n                        clueInd += allClues.length\n                    }\n                    newDirection = allClues[clueInd].direction\n                    foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd])\n                }\n                selection.rowCoord = foundCoords[0]\n                selection.colCoord = foundCoords[1]\n            }\n        } else {\n            // going forwards\n            if (this.gridIsFull(grid)) {\n                clueInd++\n                if (clueInd >= allClues.length) {\n                    clueInd -= allClues.length\n                }\n                newDirection = allClues[clueInd].direction\n                selection.rowCoord = allClues[clueInd].rowCoord\n                selection.colCoord = allClues[clueInd].colCoord\n            } else {\n                // find empty square in next word\n                while (foundCoords === null) {\n                    console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction)\n                    clueInd++\n                    if (clueInd >= allClues.length) {\n                        clueInd -= allClues.length\n                    }\n                    newDirection = allClues[clueInd].direction\n                    foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd])\n                }\n                selection.rowCoord = foundCoords[0]\n                selection.colCoord = foundCoords[1]\n            }\n        }\n        selection.direction = newDirection\n        return selection\n    }\n\n    leftArrow (board) {\n        let grid = board.grid\n        let selection = board.selection\n        if (selection.direction === \"Down\") {\n            selection.direction = \"Across\"\n        } else {\n            let boardSize = grid.length\n            let [r, c] = [selection.rowCoord, selection.colCoord]\n            c--\n            if (c < 0) {\n                c += boardSize\n                r--\n                if (r < 0) {\n                    r += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c--\n                if (c < 0) {\n                    c += boardSize\n                    r--\n                    if (r < 0) {\n                        r += boardSize\n                    }\n                }\n            }\n            selection.rowCoord = r\n            selection.colCoord = c\n        }\n        return selection\n    }\n\n    upArrow (board) {\n        let grid = board.grid\n        let selection = board.selection\n        if (selection.direction === \"Across\") {\n            selection.direction = \"Down\"\n        } else {\n            let boardSize = grid.length\n            let [r, c] = [selection.rowCoord, selection.colCoord]\n            r--\n            if (r < 0) {\n                r += boardSize\n                c--\n                if (c < 0) {\n                    c += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r--\n                if (r < 0) {\n                    r += boardSize\n                    c--\n                    if (c < 0) {\n                        c += boardSize\n                    }\n                }\n            }\n            selection.rowCoord = r\n            selection.colCoord = c\n        }\n        return selection\n    }\n\n    rightArrow (board) {\n        let grid = board.grid\n        let selection = board.selection\n        if (selection.direction === \"Down\") {\n            selection.direction = \"Across\"\n        } else {\n            let boardSize = grid.length\n            let [r, c] = [selection.rowCoord, selection.colCoord]\n            c++\n            if (c >= boardSize) {\n                c -= boardSize\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                    r++\n                    if (r >= boardSize) {\n                        r -= boardSize\n                    }\n                }\n            }\n            selection.rowCoord = r\n            selection.colCoord = c\n        }\n        return selection\n    }\n\n    downArrow (board) {\n        let grid = board.grid\n        let selection = board.selection\n        if (selection.direction === \"Across\") {\n            selection.direction = \"Down\"\n        } else {\n            let boardSize = grid.length\n            let [r, c] = [selection.rowCoord, selection.colCoord]\n            r++\n            if (r >= boardSize) {\n                r -= boardSize\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                    c++\n                    if (c >= boardSize) {\n                        c -= boardSize\n                    }\n                }\n            }\n            selection.rowCoord = r\n            selection.colCoord = c\n        }\n        return selection\n    }\n\n    gridIsFull (grid) {\n        let boardSize = grid.length\n        for (let r = 0; r < boardSize; r++) {\n            for (let c = 0; c < boardSize; c++) {\n                if (grid[r][c].value === \"\") {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n\n    getFirstEmptySpace (grid, clue) {\n        let [row,col] = [clue.rowCoord, clue.colCoord]\n        if (clue.direction === \"Across\") {\n            for (let i = col; i < col + clue.answerLength; i++) {\n                if (grid[row][i].value === \"\") {\n                    return [row,i]\n                }\n            }\n        } else {\n            for (let i = row; i < row + clue.answerLength; i++) {\n                if (grid[i][col].value === \"\") {\n                    return [i,col]\n                }\n            }\n        }\n        return null\n    }\n\n    getNextEmptySpaceWrapping (board) {\n        let grid = board.grid\n        let selection = board.selection \n        let [r, c] = [selection.rowCoord, selection.colCoord]\n        if (selection.direction === \"Across\") {\n            do {\n                c++\n                if (c >= grid.length || grid[r][c].value === \"_\") {\n                    // go to beginning of word\n                    c = c - grid[r][c-1].acrossWordIndex - 1\n                }\n                if (grid[r][c].value === \"\") {\n                    return [r,c]\n                }\n            } while (c !== selection.colCoord)\n        } else {\n            do {\n                r++\n                if (r >= grid.length || grid[r][c].value === \"_\") {\n                    // go to beginning of word\n                    r = r - grid[r-1][c].downWordIndex - 1\n                }\n                if (grid[r][c].value === \"\") {\n                    return [r,c]\n                }\n            } while (r !== selection.rowCoord)\n        }\n        return null\n    }\n}\n\nexport default new CrosswordKeyActions()"]},"metadata":{},"sourceType":"module"}