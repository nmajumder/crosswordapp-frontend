{"ast":null,"code":"class CrosswordKeyActions {\n  tabOrEnter(grid, squareSelection, shiftKey) {\n    let boardSize = grid.length;\n    let [r, c] = squareSelection.coords;\n\n    if (squareSelection.direction === \"Across\" && shiftKey) {\n      // move backwards to beginning of this word\n      while (grid[r][c].value !== \"_\" && c >= 0) {\n        c--;\n      }\n\n      if (c < 0) {\n        r--;\n        c += boardSize;\n\n        if (r < 0) {\n          r += boardSize;\n          squareSelection.direction = \"Down\";\n        }\n      }\n\n      let puzzleFull = false; // now we are on a black square or end of a row, so move back until find empty square\n\n      while (grid[r][c].value === \"_\" || grid[r][c].value !== \"?\") {\n        c--;\n\n        if (c < 0) {\n          r--;\n          c += boardSize;\n\n          if (r < 0) {\n            r += boardSize;\n          }\n        } // check for infinite loop if puzzle full\n\n\n        if (squareSelection.coords === [r, c]) {\n          puzzleFull = true;\n          break;\n        }\n      } // now we are on a blank square so find the beginning of this word\n\n\n      while (!grid[r][c].value === \"_\" && c >= 0) {\n        if (grid[r][c].value === \"?\") {\n          // this is necessary for the case where the only empty square(s) were in the word we were in, \n          // but were before the current coords we were on in that word\n          puzzleFull = false;\n        }\n\n        c--;\n      } // we went one space too far, so adjust\n\n\n      c++; // in the case of a full puzzle, the enter/tab key should go to beginning of previous word\n\n      if (puzzleFull) {\n        // move to end of prev word\n        while (grid[r][c].value === \"_\") {\n          c--;\n\n          if (c < 0) {\n            r--;\n            c += boardSize;\n\n            if (r < 0) {\n              r += boardSize;\n            }\n          }\n        } // move to beginning of prev word\n\n\n        while (grid[r][c].value !== \"_\" && c >= 0) {\n          c--;\n        } // readjust\n\n\n        c++;\n      } else {\n        // if puzzle not full, then our current word has an empty space, so find the first one\n        while (grid[r][c].value !== \"?\") {\n          c++;\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    } else if (squareSelection.direction === \"Across\" && !shiftKey) {} else if (squareSelection.direction === \"Down\" && shiftKey) {} else {}\n  }\n\n  leftArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Down\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      c--;\n\n      if (c < 0) {\n        c += boardSize;\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n          r--;\n\n          if (r < 0) {\n            r += boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  upArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Across\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      r--;\n\n      if (r < 0) {\n        r += boardSize;\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n          c--;\n\n          if (c < 0) {\n            c += boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  rightArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Down\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      c++;\n\n      if (c >= boardSize) {\n        c -= boardSize;\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n          r++;\n\n          if (r >= boardSize) {\n            r -= boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  downArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Across\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      r++;\n\n      if (r >= boardSize) {\n        r -= boardSize;\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n          c++;\n\n          if (c >= boardSize) {\n            c -= boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n}\n\nexport default new CrosswordKeyActions();","map":{"version":3,"sources":["/Users/nathanmajumder/crossword-react-app/crossword-app/src/libs/CrosswordKeyActions.js"],"names":["CrosswordKeyActions","tabOrEnter","grid","squareSelection","shiftKey","boardSize","length","r","c","coords","direction","value","puzzleFull","leftArrow","flipDirection","upArrow","rightArrow","downArrow"],"mappings":"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","sourcesContent":["\nclass CrosswordKeyActions {\n    tabOrEnter (grid, squareSelection, shiftKey) {\n        let boardSize = grid.length\n        let [r,c] = squareSelection.coords\n        if (squareSelection.direction === \"Across\" && shiftKey) {\n            // move backwards to beginning of this word\n            while (grid[r][c].value !== \"_\" && c >= 0) {\n                c--\n            }\n            if (c < 0) {\n                r--\n                c += boardSize\n                if (r < 0) {\n                    r += boardSize\n                    squareSelection.direction = \"Down\"\n                }\n            }\n\n            let puzzleFull = false\n            // now we are on a black square or end of a row, so move back until find empty square\n            while (grid[r][c].value === \"_\" || grid[r][c].value !== \"?\") {\n                c--\n                if (c < 0) {\n                    r--\n                    c += boardSize\n                    if (r < 0) {\n                        r += boardSize\n                    }\n                }\n                // check for infinite loop if puzzle full\n                if (squareSelection.coords === [r,c]) {\n                    puzzleFull = true\n                    break\n                }\n            }\n        \n            // now we are on a blank square so find the beginning of this word\n            while (!grid[r][c].value === \"_\" && c >= 0) {\n                if (grid[r][c].value === \"?\") {\n                    // this is necessary for the case where the only empty square(s) were in the word we were in, \n                    // but were before the current coords we were on in that word\n                    puzzleFull = false \n                }\n                c--\n            }\n            // we went one space too far, so adjust\n            c++\n\n            // in the case of a full puzzle, the enter/tab key should go to beginning of previous word\n            if (puzzleFull) {\n                // move to end of prev word\n                while (grid[r][c].value === \"_\") {\n                    c--\n                    if (c < 0) {\n                        r--\n                        c += boardSize\n                        if (r < 0) {\n                            r += boardSize\n                        }\n                    }\n                }\n\n                // move to beginning of prev word\n                while (grid[r][c].value !== \"_\" && c >= 0) {\n                    c--\n                }\n                // readjust\n                c++\n            } else {\n                // if puzzle not full, then our current word has an empty space, so find the first one\n                while (grid[r][c].value !== \"?\") {\n                    c++\n                }\n            }\n            squareSelection.coords = [r,c]\n        } else if (squareSelection.direction === \"Across\" && !shiftKey) {\n\n        } else if (squareSelection.direction === \"Down\" && shiftKey) {\n\n        } else {\n\n        }\n    }\n\n    leftArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Down\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            c--\n            if (c < 0) {\n                c += boardSize\n                r--\n                if (r < 0) {\n                    r += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c--\n                if (c < 0) {\n                    c += boardSize\n                    r--\n                    if (r < 0) {\n                        r += boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    upArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Across\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            r--\n            if (r < 0) {\n                r += boardSize\n                c--\n                if (c < 0) {\n                    c += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r--\n                if (r < 0) {\n                    r += boardSize\n                    c--\n                    if (c < 0) {\n                        c += boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    rightArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Down\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            c++\n            if (c >= boardSize) {\n                c -= boardSize\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                    r++\n                    if (r >= boardSize) {\n                        r -= boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    downArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Across\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            r++\n            if (r >= boardSize) {\n                r -= boardSize\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                    c++\n                    if (c >= boardSize) {\n                        c -= boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n}\n\nexport default new CrosswordKeyActions()"]},"metadata":{},"sourceType":"module"}