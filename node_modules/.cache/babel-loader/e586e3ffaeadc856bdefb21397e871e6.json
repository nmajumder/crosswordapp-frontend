{"ast":null,"code":"class CrosswordKeyActions {\n  tabOrEnter(grid, squareSelection, shiftKey, acrossClues, downClues) {\n    let allClues = acrossClues.concat(downClues);\n    let clueInd = allClues.findIndex(c => squareSelection.direction === \"Across\" ? grid[squareSelection.coords[0]][squareSelection.coords[1]].acrossClueNum === c.number && c.direction === \"ACROSS\" : grid[squareSelection.coords[0]][squareSelection.coords[1]].downClueNum === c.number && c.direction === \"DOWN\");\n    let foundCoords = null;\n\n    if (shiftKey) {\n      // going backwards\n      if (this.gridIsFull(grid)) {\n        // return beginning of prev word\n        clueInd--;\n\n        if (clueInd < 0) {\n          clueInd += allClues.length;\n          squareSelection.flipDirection();\n        }\n\n        squareSelection.coords = [allClues[clueInd].rowCoord, allClues[clueInd].colCoord];\n      } else {\n        // find empty square in previous word\n        while (foundCoords === null) {\n          console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction);\n          clueInd--;\n\n          if (clueInd < 0) {\n            clueInd += allClues.length;\n            squareSelection.flipDirection();\n          }\n\n          foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd]);\n        }\n\n        squareSelection.coords = foundCoords;\n      }\n    } else {\n      // going forwards\n      if (this.gridIsFull(grid)) {\n        clueInd++;\n\n        if (clueInd >= allClues.length) {\n          clueInd -= allClues.length;\n          squareSelection.flipDirection();\n        }\n\n        squareSelection.coord = [allClues[clueInd].rowCoord, allClues[clueInd].colCoord];\n      } else {\n        // find empty square in next word\n        while (foundCoords === null) {\n          console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction);\n          clueInd++;\n\n          if (clueInd >= allClues.length) {\n            clueInd -= allClues.length;\n            squareSelection.flipDirection();\n          }\n\n          foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd]);\n        }\n\n        squareSelection.coords = foundCoords;\n      }\n    }\n  }\n\n  leftArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Down\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      c--;\n\n      if (c < 0) {\n        c += boardSize;\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n          r--;\n\n          if (r < 0) {\n            r += boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  upArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Across\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      r--;\n\n      if (r < 0) {\n        r += boardSize;\n        c--;\n\n        if (c < 0) {\n          c += boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r--;\n\n        if (r < 0) {\n          r += boardSize;\n          c--;\n\n          if (c < 0) {\n            c += boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  rightArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Down\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      c++;\n\n      if (c >= boardSize) {\n        c -= boardSize;\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n          r++;\n\n          if (r >= boardSize) {\n            r -= boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  downArrow(grid, squareSelection) {\n    if (squareSelection.direction === \"Across\") {\n      squareSelection.flipDirection();\n    } else {\n      let boardSize = grid.length;\n      let [r, c] = squareSelection.coords;\n      r++;\n\n      if (r >= boardSize) {\n        r -= boardSize;\n        c++;\n\n        if (c >= boardSize) {\n          c -= boardSize;\n        }\n      }\n\n      while (grid[r][c].value === \"_\") {\n        r++;\n\n        if (r >= boardSize) {\n          r -= boardSize;\n          c++;\n\n          if (c >= boardSize) {\n            c -= boardSize;\n          }\n        }\n      }\n\n      squareSelection.coords = [r, c];\n    }\n\n    return squareSelection;\n  }\n\n  gridIsFull(grid) {\n    let boardSize = grid.length;\n\n    for (let r = 0; r < boardSize; r++) {\n      for (let c = 0; c < boardSize; c++) {\n        if (grid[r][c].value === \"?\") {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  getFirstEmptySpace(grid, clue) {\n    let [row, col] = [clue.rowCoord, clue.colCoord];\n\n    if (clue.direction === \"ACROSS\") {\n      for (let i = col; i < col + clue.answerLength; i++) {\n        if (grid[row][i].value === \"?\") {\n          return [row, i];\n        }\n      }\n    } else {\n      for (let i = row; i < row + clue.answerLength; i++) {\n        if (grid[i][col].value === \"?\") {\n          return [i, col];\n        }\n      }\n    }\n\n    return null;\n  }\n\n}\n\nexport default new CrosswordKeyActions();","map":{"version":3,"sources":["/Users/nathanmajumder/crossword-react-app/crossword-app/src/libs/CrosswordKeyActions.js"],"names":["CrosswordKeyActions","tabOrEnter","grid","squareSelection","shiftKey","acrossClues","downClues","allClues","concat","clueInd","findIndex","c","direction","coords","acrossClueNum","number","downClueNum","foundCoords","gridIsFull","length","flipDirection","rowCoord","colCoord","console","log","getFirstEmptySpace","coord","leftArrow","boardSize","r","value","upArrow","rightArrow","downArrow","clue","row","col","i","answerLength"],"mappings":"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","sourcesContent":["class CrosswordKeyActions {\n    tabOrEnter (grid, squareSelection, shiftKey, acrossClues, downClues) {\n        let allClues = acrossClues.concat(downClues)\n        let clueInd = allClues.findIndex(c => squareSelection.direction === \"Across\"\n                ? grid[squareSelection.coords[0]][squareSelection.coords[1]].acrossClueNum === c.number && c.direction === \"ACROSS\"\n                : grid[squareSelection.coords[0]][squareSelection.coords[1]].downClueNum === c.number && c.direction === \"DOWN\")\n        let foundCoords = null\n        if (shiftKey) {\n            // going backwards\n            if (this.gridIsFull(grid)) {\n                // return beginning of prev word\n                clueInd--\n                if (clueInd < 0) {\n                    clueInd += allClues.length\n                    squareSelection.flipDirection()\n                }\n                squareSelection.coords = [allClues[clueInd].rowCoord, allClues[clueInd].colCoord]\n            } else {\n                // find empty square in previous word\n                while (foundCoords === null) {\n                    console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction)\n                    clueInd--\n                    if (clueInd < 0) {\n                        clueInd += allClues.length\n                        squareSelection.flipDirection()\n                    }\n                    foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd])\n                }\n                squareSelection.coords = foundCoords\n            }\n        } else {\n            // going forwards\n            if (this.gridIsFull(grid)) {\n                clueInd++\n                if (clueInd >= allClues.length) {\n                    clueInd -= allClues.length\n                    squareSelection.flipDirection()\n                }\n                squareSelection.coord = [allClues[clueInd].rowCoord, allClues[clueInd].colCoord]\n            } else {\n                // find empty square in next word\n                while (foundCoords === null) {\n                    console.log(\"On clue: \" + allClues[clueInd].number + \" \" + allClues[clueInd].direction)\n                    clueInd++\n                    if (clueInd >= allClues.length) {\n                        clueInd -= allClues.length\n                        squareSelection.flipDirection()\n                    }\n                    foundCoords = this.getFirstEmptySpace(grid, allClues[clueInd])\n                }\n                squareSelection.coords = foundCoords\n            }\n        }\n    }\n\n    leftArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Down\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            c--\n            if (c < 0) {\n                c += boardSize\n                r--\n                if (r < 0) {\n                    r += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c--\n                if (c < 0) {\n                    c += boardSize\n                    r--\n                    if (r < 0) {\n                        r += boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    upArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Across\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            r--\n            if (r < 0) {\n                r += boardSize\n                c--\n                if (c < 0) {\n                    c += boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r--\n                if (r < 0) {\n                    r += boardSize\n                    c--\n                    if (c < 0) {\n                        c += boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    rightArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Down\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            c++\n            if (c >= boardSize) {\n                c -= boardSize\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                    r++\n                    if (r >= boardSize) {\n                        r -= boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    downArrow (grid, squareSelection) {\n        if (squareSelection.direction === \"Across\") {\n            squareSelection.flipDirection()\n        } else {\n            let boardSize = grid.length\n            let [r,c] = squareSelection.coords\n            r++\n            if (r >= boardSize) {\n                r -= boardSize\n                c++\n                if (c >= boardSize) {\n                    c -= boardSize\n                }\n            }\n            while (grid[r][c].value === \"_\") {\n                r++\n                if (r >= boardSize) {\n                    r -= boardSize\n                    c++\n                    if (c >= boardSize) {\n                        c -= boardSize\n                    }\n                }\n            }\n            squareSelection.coords = [r,c]\n        }\n        return squareSelection\n    }\n\n    gridIsFull (grid) {\n        let boardSize = grid.length\n        for (let r = 0; r < boardSize; r++) {\n            for (let c = 0; c < boardSize; c++) {\n                if (grid[r][c].value === \"?\") {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n\n    getFirstEmptySpace (grid, clue) {\n        let [row,col] = [clue.rowCoord, clue.colCoord]\n        if (clue.direction === \"ACROSS\") {\n            for (let i = col; i < col + clue.answerLength; i++) {\n                if (grid[row][i].value === \"?\") {\n                    return [row,i]\n                }\n            }\n        } else {\n            for (let i = row; i < row + clue.answerLength; i++) {\n                if (grid[i][col].value === \"?\") {\n                    return [i,col]\n                }\n            }\n        }\n        return null\n    }\n}\n\nexport default new CrosswordKeyActions()"]},"metadata":{},"sourceType":"module"}